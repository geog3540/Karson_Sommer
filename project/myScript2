var polygonJSONFile = 'data/RoadSummary.geojson'
// change the projection if needed *d3.geoAlbers()*
var projection = d3.geoAlbers();
// Relative placement of legend that ranges between 0 and 1.
// 0 is the start, whereas 1 i the end of each panel.
// If you want to put the legend on the left, then use 0.
// legendY = 0.5 puts the legend in the middle of the Y Axis.
var legendX = 0.1, legendY = 0.7

// id attribute and the name attribute to be used in the tooltip
var idAttribute = 'FIPS', nameAttribute = 'County';


// Height, width, margins
var widthheightRatio = 0.4;
var chartWidth = d3.select('#myMap2').node().getBoundingClientRect().width;
var chartHeight = chartWidth * widthheightRatio;
var margin = {top: 10, right: 20, bottom: 10, left:20};
var width = chartWidth - margin.right - margin.left;
var height = chartHeight - margin.top - margin.bottom;
var histHeight = (chartHeight * .25);

var att1 = "Length";
var att1alias = "Length";
var charts = [
    {'map': '#myMap2', 'var': att1, 'ax': att1alias}
];

var buttons = [
    {'btn': '#buttonLength'},
    {'btn': '#buttonVehicleMiles'}
];
activeButton = 'buttonLength';

// Functions for the chart
d3.selection.prototype.moveToFront = function() {
    return this.each(function(){
        this.parentNode.appendChild(this);
    });
}
d3.selection.prototype.moveToBack = function() {
    return this.each(function(){
        this.parentNode.appendChild(this).style('z-index', 1);
    });
}

var ordinal = d3.scaleOrdinal(d3.schemeCategory10)
.domain(["Avenue", "Street", "Highway", "Way", "Road", "MALFORMED", "NULL"])

var current_scale = ordinal;

// Set up the legend dimensions and style
var holdLegend = d3.legendColor()
.shapeWidth(15)
.shapeHeight(5)
.shapePadding(10)
.orient('vertical')
.useClass(false)
.scale(ordinal)


var polygons;
var proj;
    //this is where you read the json polygon data
d3.json(polygonJSONFile).then(function(data) {
        // set up the projection
        polygons = data;
        proj = d3.geoPath().pointRadius(2);
        proj.projection(projection.fitSize([width, height], polygons));

        // Set the buttons up for interactivity
        buttons.forEach(function(d) {
            d3.select(d.btn).on('click', function() {
                var buttonid = d3.select(this).node().id;
                activeButton = buttonid;

                //current_scale = d.scale;
                if(activeButton == 'buttonLength') {
                    charts[0].var = "Length"
                    charts[0].ax = "Length"
                } else if(activeButton == 'buttonVehicleMiles') {
                    charts[0].var = "Vehicle_Miles"
                    charts[0].ax = "Vehicle_Miles"
                } else {
                    err.message;
                }
            });
        });

        // For each input attribute make a map and a histogram
        updateMap2(polygons)

});


function updateMap2(polygons) {
        charts.forEach(function(d) {
            // Set scales + variable for each map
            d3.select("#panelSVG2").remove();

            var dependent = d.var;

            // tooltip for maps
            var tooltipD3 = d3.select(d.map)
            .append("div")
            .attr("class", "tooltipD3")
            .attr("id", function() { return d.map.substr(1) + '-tooltip'; })
            .style('display', 'none');

            // Set up the panel that includes the map and the legend
            var panel = d3.select(d.map).append("svg")
            .attr("id","panelSVG2")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // append the choropleth map
            var map = panel.selectAll('.path')
            .data(polygons.features)
            .enter().append('g');
            map.append('path')
            .attr("class", function(e) { return classPolygon2(e, d.map); })
            .on('mouseover', function(e) { return mouseOver2(e, dependent); })
            .on('mouseout', mouseOut2)
            .on('mousemove', mousemoveFunc2)
            .attr("d", proj)
            .style('fill', function(c) {
                return current_scale(c.properties[d.var]);
            });


            holdLegend.labelFormat(d.form);
            // add the legend
            panel.append('g')
            //.attr("class", "legendQuant")
            .attr("transform", "translate(" + (width * legendX) + "," + (height * legendY) + ")");
        })
}

window.addEventListener("resize", displayWindowSize2);
function displayWindowSize2() {
    chartWidth = d3.select('#myMap2').node().getBoundingClientRect().width;
    chartHeight = chartWidth * widthheightRatio;
    margin = {top: 10, right: 20, bottom: 10, left:20};
    width = chartWidth - margin.right - margin.left;
    height = chartHeight - margin.top - margin.bottom;
    histHeight = (chartHeight * .25);

    hist_scale = d3.scaleLinear().range([0, width]); // hist X
    hist_y = d3.scaleLinear().range([histHeight, 0]);	// hist Y
    bins = d3.histogram()
    .domain(hist_scale.domain())
    .thresholds(10);

    updateHistogram(polygons);

    proj.projection(projection.fitSize([width, height], polygons));

    updateMap(polygons);
}

function classPolygon2(polygon, map) {
    // Function to create the correct CSS style name for each polygon.
    // (e.g. Johnson county polygon, FIPS 19) >> 'polygons.lung.polygon19'
    return 'polygons ' + map + ' polygon' + polygon.properties[idAttribute];
}

function getBoundingBoxCenter2 (selection) {
    // get the DOM element from a D3 selection
    var element = selection.node();
    // use the native SVG interface to get the bounding box
    var bbox = element.getBBox();
    // return the center of the bounding box
    return [bbox.x + bbox.width/2, bbox.y + bbox.height/2];
}

function mouseOver2(polygon, attr) {
    /* Mouse over routine
    Highlight the polygon on all maps, adjust the tooltip */
    //enter the id of the polygon
    var id = polygon.properties[idAttribute],
    //enter the name of the polygon
    name = polygon.properties[nameAttribute];

    return charts.forEach(function(d) {

        var map = d3.select(d.map);
        var tip = d.map + '-tooltip';
        // select the polygon by its id attribute
        map.select('.polygon'+id)
        .moveToFront()
        .style('stroke', 'black')
        .style('opacity', '1');

        // map tooltip
        d3.select(tip)
        .style('display', null)
        .html("<p><b>" + name + " " + nameAttribute + "</b><br/>" + d.var +
        ": " + polygon.properties[d.var] + "</p>");

    });
}

function mousemoveFunc2(polygon) {
    /* Moves tooltip */
    //the id of the polygon
    var id  = '.polygon' + polygon.properties[idAttribute];

    charts.forEach(function(d) {
        var map = d3.select(d.map);
        var polygonOnMap = getBoundingBoxCenter2(map.select(id));
        var tip = d.map + '-tooltip';

        var offsetY = d3.select('#myMap2').node().getBoundingClientRect().y
        var offsetX = d3.select('#myMap2').node().getBoundingClientRect().x

        d3.select(tip)
        .style("top", (polygonOnMap[1] + offsetY + window.pageYOffset - 40) + "px" )
        .style("left", (polygonOnMap[0] + offsetX + window.pageXOffset + 30) + "px");
    });
}

// Resets the polygon after mouseout
function mouseOut2(polygon) {

    var id = polygon.properties[idAttribute],
    name = polygon.properties[nameAttribute];

    charts.forEach(function(d) {

        var map = d3.select(d.map);
        var tip = d.map + '-tooltip';

        map.select(('.polygon'+id))
        .style('stroke', "#dadada")
        .style('opacity', '0.85');
        // map tooltip
        d3.select(tip)
        .style('display', "none");
    });
}